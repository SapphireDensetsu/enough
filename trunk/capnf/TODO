* When returning a new generated object, that depends on other
   subobjects, the new obj is set locally. However, in the 'add'
   example setting = sets it, but if we now request 'a' or 'b',
   they will still return the old value because they have not been
   replaced to reflect the new value of =
  * Solutions:
    1. objects are never stored locally as subobjects?
    2. if a local subobject is "set" then we automatically call
       request on all other subobjects?

# FUTURE WORK
* Only instances should exist, no such thing as class. A "class" is an
   instance maker that possibly keeps track of its instances. The new name for "instances" is objects. 

  * Each object has:
    * A list of 'subobjects'
    * request granter - you pass a request to the object and it
   returns the result

  * Queries (or requests) to objects are done using "names" which are 
   actually other objects which you need to attain in the first place?
   Or perhaps allow the name to be an immutable value that can be
   generated by each object (such as a string)?

  * Events: how, when, what, why. What if i want to know when
   something happens to one of my subobjects? 
 
  * Future questions:
    * How is subinstance containing handled? Simply a list of
     (references to) sub-instances?
    * Should there be 'weak' references in the model? Implement via
     facets of an object? When is an object destroyed?, and are all
     references equal?

* Decide whether basic arithmetic is a "capability", or maybe the
   sum/product functions are objects and you need to request
   calculations from them? or hold a reference in order to use them?

* Make basic capabilities: scheduling, object creating (memory?)