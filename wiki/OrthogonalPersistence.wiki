#summary Definition and applications

= What is Orthogonal Persistence? =

== Seperated Storage ==
Most operating systems have a concept of File Systems. Every process that wishes to store information persistently must use the OS's system calls to create a file on a persistent storage media (e.g. hard drive). The task of storing data on disk is seperated from storing data in memory such as RAM. For this reason, we refer to this method as "Seperated storage".

== Problems with Seperated Storage ==

_This section should be expanded with more convincing arguments_

Take the common text editor (such as notepad) as an example. You edit the text file in the window of the application. That is, you enter data. The data is there. In many cases you will want to "save" it. But for the programmer of the notepad application, this is a "hassle" - he (or she) needs to explicitly open a file on the disk, write the data, and close the file. If you modify the text and want to save the new version, the program must yet again open a file, etc.

For a more complex application, such as a full-fledged word processor, the data is not a simple string of text. It exists in memory in a complex set of structures, probably containing structures such as lists that require pointers. The situation gets worse for applications that want to continously "persist" their data. They may use OS features such as memory mapping, but this puts another overhead to a very basic programming goal - *NOT LOSING YOUR DATA!*

== Solution(s)? ==
_Currently the only solution presented is Orthogonal Persistence. Expand._

*Orthogonal Persistence* is an alternative to storing data in process-managed files. _Orthogonal_ in this case means that there is always persistence. The idea is to let the operating system take care of persistence instead of having each process manage data that needs to be saved. 
The following is an outline of one possible way to achieve orthogonal persistence:
 * Every application stores it's data in memory, always, and never has to access files.
 * Once in a (short) while, the operating system has a "checkpoint" where all the memory is stored on disk.
 * The user can always request a checkpoint to make sure his most recent data is saved.
 * The checkpoints are performed in an incremental manner: only portions (pages) of memory that have been modified need to be saved to disk.
 * Special algorithms make this operation efficient.
 * From application point of view, all data is stored only in the main memory.
 * Features such as heirachial organization of objects are still supplied by some service of the OS (probably a built-in application), but even this has nothing to do with persistenting data on disk. It is a database with data in memory. The OS deals with saving this data.

= Advantages =
== No programming overhead ==
Applications don't have to deal with files. They simply create a new object in memory, and the operating system takes care of the rest. If an application needs to "delete" data from the disk, it simply frees the memory used by that object (or use an equivalent form of "freeing memory" provided by orthogonally persistent OSs).

== Persistent applications ==
Persistence goes _beyond_ data. The applications themselves are stored automatically on disk. This leads to several new features that are otherwise impossible. 

=== No junk on disk, no installers, no "orphaned files" ===
In orthogonal persistence, the applications themselves are objects in memory. This memory was orignally allocated when the application was "installed". However, there is no concept of installation in the usual sense - there is no need to copy files to specific locations (there is no such thing as a file). Instead, the application just "starts living" straight into memory. 

==== Example problem ====
An application such as a word processor usually installs with files of different sorts:
 * The main executable
 * Additional libraries (DLL's or shared objects)
 * Application data - localization data, icons, help files (which are actually directories or archives including many files and multimedia content)
 * User-specific information (stored in the user's home directory or in a database such as the registry)
 * Built-in user data (supplied by the creator of the word processor):
  * Templates
  * Multimedia (clipart, images, sounds)
  * Example documents

There is a whole lot of code written just to handle these files:
The installer has to deal with putting each of these files in the correct location, and the uninstaller has to know which files were installed in order to delete exactly those.
The application itself has to know where to look for these files on disk and maybe allow the user to control these locations.

==== Solution ====
With *Orthogonal Persistence*, the application and all it's data are objects in memory. It is not important how these objects came into existence on the computer. These objects may be acquired by reading from some media or the network. In any case, once the application exists on the machine, it is the OS that takes care of "saving" it. 

In the word processor example, the executable, libraries and all other data are actually objects in memory. Some data must still be organized - clip art images should probably be stored in some sort of database. This is why we still need a "database service" to manage our objects for us (this is one of the unclear points).

*The main advantage*: when the user wants to create a new document, all the application needs to do is allocate memory and initialize a new "document object" in memory. The application never needs to save this document. In fact it doesn't even need to use any system call to "map" this to a disk file. It also never needs to save it's internal state (which documents are open, default settings, etc.). The application is persisted by the OS.


==== Junk ====
When we say "junk on disk" we mean the general clutter that occurs because each program needs to store it's own files in an arbitrary amount and location. It is true that most OS suggest putting applications in certain locations (e.g. under the directory Program Files). However, nothing enforces this. Also, application may access files that are outside their installed location, and this inherently leads so clutter that is only controlled by the good will of application programmers, and by how organized each user is.


==== Installers ====
_I really don't remember how this works! Expand._
Since all data is persisted automatically we don't really need an installer. There is no need to remember where each file must go.


= Problems and unclear points =
_Expand..._

 * How are applications really organized in memory? How does the operating system know what is an application and where is it in memory? 
 * Sharing data between application - if we have a word processor documents we might want to use different applications to edit it. How is this done?
 * Does an application's executable turn into a live process from the moment it is born? Is so, how do we run several instances of an application?
 * Installers
  * Organization of data in database - if we still need to register object types with a central database so that many applications will be able to share objects, what happens with installers? 
  * We still need installers because someone has to register new objects in this database, and also notify the operating system about new applications that pop into existence.

= Additional Information & References =
_Put some more references, find publications on Orthogonal Persistence_

[http://en.wikipedia.org/wiki/Orthogonal_persistence Orthogonal Persistence on WikiPedia]