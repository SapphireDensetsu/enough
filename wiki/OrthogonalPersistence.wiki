#summary Definition and applications

= What is Orthogonal Persistence? =

== Seperated Storage ==
Most operating systems have a concept of File Systems. Every process that wishes to store information persistently must use the OS's system calls to create a file on a persistent storage media (e.g. hard drive). The task of storing data on disk is seperated from storing data in memory such as RAM. For this reason, we refer to this method as "Seperated storage".

== Problems with Seperated Storage ==

_This section should be expanded with more convincing arguments_

Take the common text editor (such as notepad) as an example. You edit the text file in the window of the application. That is, you enter data. The data is there. In many cases you will want to "save" it. But for the programmer of the notepad application, this is a "hassle" - he (or she) needs to explicitly open a file on the disk, write the data, and close the file. If you modify the text and want to save the new version, the program must yet again open a file, etc.

For a more complex application, such as a full-fledged word processor, the data is not a simple string of text. It exists in memory in a complex set of structures, probably containing structures such as lists that require pointers. The situation gets worse for applications that want to continously "persist" their data. They may use OS features such as memory mapping, but this puts another overhead to a very basic programming goal - *NOT LOSING YOUR DATA!*

== Solution(s)? ==
_Currently the only solution presented is Orthogonal Persistence. Expand._

*Orthogonal Persistence* is an alternative to storing data in process-managed files. _Orthogonal_ in this case means that there is always persistence. The idea is to let the operating system take care of persistence instead of having each process manage data that needs to be saved. 
The following is an outline of one possible way to achieve orthogonal persistence:
 * Every application stores it's data in memory, always, and never has to access files.
 * Once in a (short) while, the operating system has a "checkpoint" where all the memory is stored on disk.
 * The user can always request a checkpoint to make sure his most recent data is saved.
 * The checkpoints are performed in an incremental manner: only portions (pages) of memory that have been modified need to be saved to disk.
 * Special algorithms make this operation efficient.

= Advantages =
== No programming overhead ==
Applications don't have to deal with files. They simply create a new object in memory, and the operating system takes care of the rest. If an application needs to "delete" data from the disk, it simply frees the memory used by that object (or use an equivalent form of "freeing memory" provided by orthogonally persistent OSs).

== Persistent applications ==
Persistence goes _beyond_ data. The applications themselves are stored automatically on disk. This leads to several new features that are otherwise impossible. 

=== No junk on disk, no installers, no "orphaned files" ===
In orthogonal persistence, the applications themselves are objects in memory. This memory was orignally allocated when the application was "installed". However, there is no concept of installation in the usual sense - there is no need to copy files to specific locations (there is no such thing as a file). Instead, the application just "starts living" straight into memory. 

==== Example ====
An application such as a word processor usually installs with files of different sorts:
 * The main executable
 * Additional libraries (DLL's or shared objects)
 * Application data - localization data, icons, help files (which are actually directories or archives including many files and multimedia content)
 * User-specific information (stored in the user's home directory or in a database such as the registry)
 * Built-in user data (supplied by the creator of the word processor):
  * Templates
  * Multimedia (clipart, images, sounds)
  * Example documents

There is a whole lot of code written just to handle these files:
The installer has to deal with putting each of these files in the correct location, and the uninstaller has to know which files were installed in order to delete exactly those.
The application itself has to know where to look for these files on disk and maybe allow the user to control these locations.

With *Orthogonal Persistence*, the application and all it's data are objects in memory. It is not important how these objects came into existence on the computer. These objects may be aquired by reading from some media or the network. What IS important is that once the application exists on the machine, it is the OS that takes care of "saving" it. 


==== Junk ====
When we say "junk on disk" we mean the general clutter that occurs because each program needs to store it's own files in an arbitrary amount and location. It is true that most OS suggest putting applications in certain locations (e.g. under the directory Program Files). However, nothing enforces this. Also, application may access files that are outside their installed location, and this inherently leads so clutter that is only controlled by the good will of application programmers, and by how organized each user is.

= Problems =
_Missing. Expand..._

= Additional Information & References =
_Put some more references, find publications on Orthogonal Persistence_

[http://en.wikipedia.org/wiki/Orthogonal_persistence Orthogonal Persistence on WikiPedia]