#summary Adaptive Profiling definition and applications

_this sections needs better examples_

= Summary =
Adaptive profiling is the ability of a system to change dynamically in a way that improves it's performance. The method of change is the duplication or movement of components between host platforms. This is made possible by [Capabilities], [OrthogonalPersistence] and the ability of the operating system to transparentely serialize and move objects between hosts, while retaining their cross-references across a network, transparently.

= Background =
Software is typically made of a large complex of entities that communicate with each other. Some of these entities are actors (programs) and some are information (data). In local, non-networked programs, these entities are all running and stored in the same host computer.  In recent times, though, more of these entities are linked, referenced and distributed over a network.  Examples include:
  * The web (where the data sits separately from the browser code)
  * The X protocol (where the main code sits separately from the display code)
  * File system shares (where the file data sits separately from the code to access it)

Due to differing resources' availability and differing resource requirements of these hosts and components, and due to the dynamic nature of both, it is often desirable to dynmiaclly move or duplicate these components between host computers.

Due to the architecture of today's operating systems and languages, there is no way to seamlessly duplicate or move components between computers.  

= A "component" =

A "component" is either code or data and has many properties:
  * Its size
  * Its behaviour or content
  * Its references and links to other components
  * Its requirements:
    * Space and space-performance (disk and ram availability)
    * Run speed (cpu power)
    * Communication speed (networking speed)

A component by itself is typically useless.  Its usefulness is usually a result of its inter-connection with other components. For example, a web browser is useless without its connection to the webpage data.  It is also useless without its connection to the screen, to display its data.

= Desirability of nomad components =

The above-mentioned resources are all limited, and have differing availabilities on different hosts. If a component is movable or duplicate-able from one host to the next, then the differing resource requirements of the components can be satisfied in a better way.

== Current examples of duplicated components ==

Nowadays, some components are already duplicate-able and seamlessly moved. This is a "cache" and it often duplicates components from one host to the other, when the communication speed is low. This is, however, just a limited form of duplication, and far more can be achieved.

== Examples of potential gains ==

=== Web Browsers ===

Suppose we have a web site that contains a small code component that generates responses for browsers.  Lets call the web site computer WebSite, and the client browser computer WebBrowser.  This is actually quite a common scenario.  Let us suppose that the code component in WebSite is referencing a small piece of data in WebSite and other sites in the net.  WebBrowser, who has a very slow connection, will have to send multiple requests to WebServer, so that it runs the small code component, generate a small response, and send it back.  WebBrowser is perfectly capable of running the small code component, containing the small piece of data and referencing other sites, but due to the architecture of the system, it has to pay severe network penalties in order to access the functionality (This is even true now, as I am editing this wiki).  If the small code component, the small data and links to other sites were seamlessly copied to WebBrowser the performance of the system could be enhanced.

=== X server ===

You may or may not know, but an X server seamlessly transmits all of the mouse movements and clicks from your displaying computer to a client computer that runs the logic of the program.  Most of these network-hogging mouse movements are quickly discarded by a typically small section of the client logic code (the gui toolkit code).  If the Toolkit code was automatically and seamlessly moved to run in the displaying computer, most of the network use would be eliminated.

=== File System shares ===

Almost every work environment and a lot of the home networks have multiple computers. A common way of sharing data is using file system shares, where remote files are accesses in a similar way to local ones.  This is done at the file system level, where reqeusts such as "list this directory" and "delete this file" are sent.  This is great when what you are doing over the share is listing directories and deleting files.  However, no request to "delete this entire directory and all subdirectories" exists, and definitely some more bizarre operations that may be requested by programs such as "get me a list of all files that end with .mp3 in this directory and all subdirectories" exist.  It doesn't make sense to add these requests to the shared file system protocol.  In order to implement these requests, many tiny requests are ping-ponged across the network (list directory, list subdirectory, delete file 1, delete file 2, etc etc), and it is often much more efficient to go and perform the high-level deletion request at the appropriate computer manually.

If the (small) code component that implements the high-level logic (for example enumerating all subdirectories and filtering files that have .mp3 in them) was seamlessly copied to the file system share computer, the requests would become local instead of hopping over a slower network.  This could speed up work with file system shares, without having to jump between controlling multiple computers.

=== Distributed computing ===

A lot of work in computer science, is devoted to distributed computing, where specifically code components can be asked to run remotely in order to use the network's CPU resources more effectively.  Programs that are able to do this are specifically tailored for this need and profiled manually in order to decide how to distribute them.  With Adaptive Profiling, any code component would be able to be copied or moved to another computer in order to free up some cycles from a busy CPU and use up some cycles of an idle CPU.  This would make all programs properly distributed.

= How? =

Now that we've seen that the ability to move components in order to better utilize the resources of the computers of the network is desirable (and even very desirable in many cases), how do we go and implement it?

== The Operating System must know ==

Today, the entities operating systems know about are processes/threads, files, and the computer's objects/resources.  The operating system has no idea about how to interpret the content of the file, and it definitely has no idea about which components exist inside processes/threads.
In order to be able to move components between host computers, the components must be explicit. Instead of knowing processes/threads, the operating system must know the high-level objects and the type of each object. It must know the code in a high-level form (i.e: bytecode) that is possible to recompile for different architectures in order to utilize different computer architectures.

The operating system must also know about the references between the components. It must know the exact type of the refered object, and how it is referred, and from where.  Once it knows this, it may serialize local references into transparent [NetworkReferences network references] to these components when sending the component to different host computers.

== Moving vs. Copying ==

Typically all immutable things can be copied across the network (i.e cached) whereas all mutable data must be either temporarily copied, or moved.  So in general, code components would be copied, as they are immutable, while a database would have to be moved.
All such movements or copying will be referred to as migrations.

== Profiling ==

Now that the operating system is capable of copying components between computers, it must decide when it is _desirable_ to do so.

=== Desirability of moving components ===

In order to figure whether the migration of a component is desirable, we must take into account all of the gains and costs of the move.

==== Costs ====

  * Migrating a component entails:
    * Serializing it
    * Transmitting it over the network
    * Deserializing it

Serializing and Deserializing are of negligible costs compared to the transmission over the network, and could thus be ignored.
The Operating System must be able to evaluate the costs of the migration, by estimating the cost of tranmission over the network. This cost entails the time required for the transmission (based on the object size and network speed) and the cost associated with that specific network tranmissions (i.e: pay-per-kilobyte).

==== Gains ====

By migrating a component we achieve two things:
  * We shift use of resources from one computer to the next.
  * We change the topography of the links between components.

The resources we can shift are:
  * Fast Space (RAM, low-level caches, etc)
  * Slow space (Disk)
  * CPU usage
  * Network use

The topography change means that some of the links between the components become remote instead of local, and some become local instead of remote.

==== Decision ====
In order to make an informed decision, the operating system must know of all these factors.  To do this it must profile the components.

TEMPORARY, HAD TO GO, WILL CONTINUE EDITING THIS LATER.

When deciding whether to make a migration, the operating system should measure the costs as described above, and calculate the gains.  In order to calculate the gains, it should consider each resource and its scarceness in each of the host computers.  It should obviously attempt to utilize resources in the host that is less scarce.  Perhaps more importantly, it should review the topography change and 

= Special cases =

Some components are strongly bound to a host computer. For example, the host's devices (mouse, keyboard) and their corresponding software components cannot be migrated (Until teleportation is possible :-).
Some components may be secret (a secret database) and one may not want to send them across the network to an untrusted host computer.
In these special cases it should ofcourse be possible to mark a component non-migratable.