#summary A library for enough projects
#labels InProgress

= Outline =
The current design is the result of our current livec/graphui implementation efforts, where we learned important lessons.

 * *Purpose:* to allow development of enough projects (e.g. LiveC, Graphui) using a design based on ideas in Enough.
 * *Design:* Currently, the library's design reflects:
   * [DifferentialComputing Differential computing] using deltas and observation
   * [LazyEvaluation Lazy Evaluation] using "expression objects"
   * [ObjectRevisionControl Object-based revision control] using deltas, histories, and hierarchical baselines. 
   * [RetroactiveMacros Retroactive macros] made possible by history recording and visualization.

 * *Future features* that will become possible after we complete this phase:
   * [MemoryManagement Intelligent memory management (recomputability)]: Deciding which objects should be cached (in-memory), swapped (cached in disk), or dumped (recomputed when necessary) according to the computation costs, storage costs, access frequency and importance. This requires developing some algorithms...
   * [OrthogonalPersistence Orthogonal persistence] (or a variant thereof): Transparent swapping of unused objects to disk.

= Details =

== Layer 1: Observable objects with deltas and expressions ==
First, a list of non-detailed, basic definitions:
 * *Observable*: an object that sends notifications when it is changed (mutated). There are usually multiple "observation ports" for an observable object (_Open/Close_, below). Some observable types are:
    * `List` (notifies when items are added, removed or replaced)
    * `Dict` (notifies when keys are added, removed or a value is replaced)
    * `ValueContainer` (notifies when its pythonic value changes)
    * _Expressions_ are also observable, because they have observable inputs (if an input  changes, the output might also change).
 * *Observer*: an entity that is registered to receive notifications about changes in an observable object. 
 * *Delta*: represents a change in an object (e.g. `ListItemAdd` represents the adding of an item to a list). Deltas do not refer to a specific object that has changed - they only represent the change that can be applied to an object. Each object type (`List`, `Dict`, etc.) has its own set of deltas classes specific to that type.
    * *Notifications* of observable objects are actually deltas. When a change occurs, an observable sends a delta describing the change to the observers.
 * *Expression*: a "computable" that can be thought of as a function: _Expression(s) -> Expression_ that maps input expressions to an output expression. 
   * Note that the expression doesn't have an "output" really, the expression object itself is the output. 
   * Expressions *observe* their inputs, so that when the input has changed, the expression knows about it. 
   * An expression may have no input (see `Literal` below).
   * Normally, an expression doesn't store the result of its operation. It calculates the result lazily (see _Open/Close_, below). Storing the result is called _caching_, and in principal this can be done "intelligently", considering performance tradeoffs, resources, etc.
   * Some example expressions are:
     * `Literal` - the expression that simply represents a value
     * `DictMap` - *TODO*
     * `WithDelta` - see _revision control_, below.

=== Motivation for Observation ===
It might seem that observation is a by-product of the mutability of some base objects (such as `List`). Can we do without observation, and only use deltas on immutable objects? The answer is no. The main reason is that expressions need to know if their inputs changed. Otherwise, an expression will have to re-calculate itself every time somebody tries to use its value. Also, however uses its value, does not know if that value has changed a moment later, it has to keep checking.

=== Open/Close of Observables ===
*TODO*

=== Propogation of changes ===
*TODO*

=== Example ===
*TODO*

== Layer 2: Revision control ==
Since all changes in layer 1 are represented by deltas and expressions on which they occur, the revision control can understand not only _how the change looks_ but also _what the change was_. For further discussion see [ObjectRevisionControl Object-based revision control].

Definitions:
 * `WithDelta` - an *expression* that takes (expression, delta) and represents the given expression with the delta applied. `WithDelta` does not actually _apply_ the delta, it only _represents_ the combination: value+change. The given expression can be thought of as a "base revision" and the `WithDelta` object as a "new revision" which is equal to "base revision" + delta.

*TODO* Define: revision, revision getter, history, baseline.