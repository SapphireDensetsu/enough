#summary Formal definitions for deltas

= Introduction =
"Delta Algebra" is the name for a formalism of the concept of deltas used in PackageLibrary. The relation between this formalism and the practical deltas used in the Enough PackageLibrary is not well defined. This formalism was created mainly for amusement, but it may find future applications in (possibly automatic) formal verification of a system that uses the delta concept.

== Notation ==
 * Functions are in _italic_, e.g. _f_.
 * Sets are in *bold*, e.g. *V1*.
 * The empty set is {}.

= Invertible functions group =
== Basics ==
 * *V* is the set of all values.
 * *Common domain* of _f_ and _g_ is the intersection of their domains.
 * We define F,,inv,, as the set of invertible functions. These are functions satifying:
   * _f: *V1* -> *V2*_, where *V1* and *V2* are subsets of *V*.
   * _f_ is *invertible*: There exists _f^-1^_ such that _f^-1^_(_f_(x)) = x for every x in *V1*.
     * By definition, we have _f^-1^_: *V2* -> *V1*.
 * *Equality*:
   * Given the following:
     * _f_: *V1* -> *V2*, where *V1*, *V2* are subsets of *V*
     * _g_: *W1* -> *W2*, where *W1*, *W2* are subsets of *V*
     * _intersection_(*V1*, *W1*) != {}
     * *X1* is a subset of *V1* and also a subset of *W1* (a subdomain of both _f_ and _g_).
   * We define _f_ = _g_ _in *X1*_ iff for every x in *X1* _f_(x) = _g_(x).
   * If *V1* = *W1* ( = *X1*) then we say that _f_ = _g_ _totally_, or: _f_ and _g_ are totally equal, or: _f_ and _g_ are identical. In this case the two functions are indistinguishable and are one and the same. 
     * Trivial result: _f_ = _g_ _totally_ iff  _f^-1^_ = _g^-1^_ _totally_.
   * The *Greatest subdomain of equality* is the largest set *X2* such that *X2* is a subdomain of both _f_ and _g_, and such that _f_ = _g_ in *X2*.
   * *Theorem e1*: If _f_ = _g_ _in *X1*_ then _Image_(_f_ on *X1*) = _Image_(_g_ on *X1*) =  *Y*, and *Y* is a subset of _intersection_(_Image_(_f_), _Image_(_g_)).
     * *Proof*: Since _f_ = _g_ _in *X1*_ we have for every x in *X1* a value y = _f_(x) = _g_(x). Call the set of all y's: *Y*. By definition every y in *Y* is in _Image_(_f_) and also in _Image_(_g_), so it is in their intersection.
   * *Theorem e2*: Using theorem e1's defintions. If *Y* = _intersection_(_Image_(_f_), _Image_(_g_)) then *X1* is the greatest subdomain of equality.
     * *Proof*: *TODO*.
   * *Theorem e3*: The restriction of _f_ to *X1* a subset of the common domain, named _f,,x1,,_ is totally equal to the restriction of _g_ to *X1*, named _g,,x1,,_.
     * *Proof*: _f,,x1,,_ and _g,,x1,,_ have the same domain, and the same image, and are therefore totally equal.
 * The *identity function* _id_: *V* -> *V* maps every value to itself. By definition _id_ = _id^-1^_.
   * *Theorem id1*: There is only one identity function in F,,inv,,.
      * *Proof*: If _f_: *V* -> *V* is an identity function, then _f_(x) = x for every x in *V* by definition. However, x = _id_(x) because we have already defined the identity function _id_. Therefore by definition _f_ = _id_ (totally) and they are the same function.
   * *Theorem id2*: For every _f_: _f_ _id_ = _id_ _f_ = _f_ in the domain of _f_. 
     * *Proof*: _f_ _id_ means by definition _f_(_id_(x)) = _f_(x) = _id_(_f_(x)).
   * *Theorem id3*: _g_ _f_ = _h_ _f_ in the domain of _f_, if and only if: _g_ = _h_ in the image of _f_. 
     * *Proof*: 
       # =>: The first equation means that for every x in the domain of _f_, _g_(_f_(x)) = _h_(_f_(x)). We can name y = _f_(x), then: _g_(y) = _h_(y) for all y in the image of _f_, which means that _g_ = _h_ in the image of _f_.
       # <=: The second equation is: _g_ = _h_ in the image of _f_. For all x in the domain of _f_, there exists y = _f_(x). So for all x, we get _g_(_f_(x)) = _h_(_f_(x)).

== Group ==
The set of invertible functions F,,inv,, with *composition* and *inversion* form a *group*.
 * *Composition*: (_f_ o _g_)(x) = _f_(_g_(x)). In our notation: _f_ o _g_ = _fg_.
   * *Associativity*: _(fg)h_ = _f(gh)_ because _(fg)h_(x) = _f_(_g_( _h_(x) )) = _f_( _g_(_h_(x))) = _f(gh)_(x) for every x in the domain of _h_.
     * By induction, any finite composition of functions is associative, and we can always simply write: _f,,1,,f,,2,,f,,3,,f,,4,,...f,,n,,_ without parenthesis.
 * *Inversion*: by definition every function in the set of invertible function has an inverse. Therefore we may define the _inverse operation_ notated by ^-1^.
   * *Theorem inv1*: _Symmetry of reverse_: If _f^-1^_ is the inverse of _f_, then _f_ is the inverse of _f^-1^_. (Trivial proof).
   * *Theorem n2*: _Uniqueness of reverse_: For every _d_ there exists exactly one reverse. 
     * *Proof*: If _d,,1,,_ is another reverse of _d_, then _d_ + _d,,1,,_ = _d,,0,,_ = _d_ + _-d_ => {theorem e3} => _d,,1,,_ = _-d_.


= Extensions to the group =
 * *A* is a set of functions, called the *atomic set*. Every delta in *A* is called an *atomic delta*.





= More definitions =
 * *Atomic delta*: _d_ is an *atomic delta* if and only if there is no pair (_d,,1,,_, _d,,2,,_) such that _d,,1,,_ + _d,,2,,_ = _d_ in the domain of _d_.
 * *Common applicable delta* of a set of values, is a delta that is applicable to all values in the set.
 * *Value class*: A *value class* is a set of values with at least one common applicable delta.
    * Example: the set of all `Dict`s is a value class (because they have a common applicable delta, in fact they have several).
 * *Delta path*: A *delta path* from _v,,1,,_ to _v,,2,,_ is any ordered sequence of *atomic* deltas (_d,,1,,_, _d,,2,,_, ..., _d,,n,,_), such that _A,,dn,V1,,(A,,d(n-1),V1,,(...(A,,d1,V1,,(_v,,1,,_)))..))_ = _v,,2,,_.
   * Note that by definition there is a single delta (_d,,1,,_+_d,,2,,_+...+_d,,n,,_) that is the same as the above application of the sequence, but it is not a delta path because it is not atomic.
   * Also, there is an infinite number of arbitrary long delta paths from any value to any value, because we can always add another pair of canceling atomic deltas to the path: (_d_, -_d_).
   * *Theorem (path 1)*: _Reverse delta path theorem_: Every finite delta path from _v,,1,,_ to _v,,2,,_ has a reverse delta path from _v,,2,,_ to _v,,1,,_.
     * *Proof*: A delta path from _v,,1,,_ to _v,,2,,_ consists of a sequence of atomic deltas, {_d,,1,,_, _d,,2,,_, ..., _d,,n,,_}. We can build a delta, the sum _s,,n,,_ = (_d,,1,,_ + _d,,2,,_ + ... + _d,,n,,_), which will lead also from _v,,1,,_ to _v,,2,,_. Using axiom 1 (every delta has a reverse), this composite sum also has a reverse -_s,,n,,_. If -_s,,n,,_ is atomic, we have found a reverse delta path. If not, by definition there exists a set of deltas who's sum is -_s,,n,,_ and they are the reverse delta path.
   * *Theorem* (path 1a): Like theorem (path 1) but the reverse path is of the same length as the original path.
     * *Proof*: *TODO*
   * *Theorem* (path 1b): Like theorem (path 1) but the path is infinite.
     * *Proof*: *TODO*
 * *Length of delta path*: The length of a delta path is the number of deltas in the sequence.
 * *Delta distance*: the delta distance from _v,,1,,_ to _v,,2,,_ is the shortest length of any delta path from _v,,1,,_ to _v,,2,,_.
    * This is written: |_v,,1,,_ - _v,,2,,_|*,,D,,*. 
    * *Theorem (distance 1)*: |_v,,1,,_ - _v,,2,,_|*,,D,,* = |_v,,2,,_ - _v,,1,,_|*,,D,,*.
      * *Proof*: Using the existence of a reverse delta for every delta in the path from _v,,1,,_ to _v,,2,,_, we can always construct a reverse path of the same length. The reverse path can not be shorter, because if there is a way to cancel out deltas on the reverse path, the reverse of the same pair of deltas in the forward path could have also been canceled out.
 
 * *Conflicting deltas*: a pair of deltas is said to _*conflict* in *V1*_ (*V1* is a subset of *V*) if and only if the deltas are *not commutative* under addition, in *V1*.
   * *Theorem (conflict 1)*: _An empty delta never conflicts_.
     * *Proof*: Trivial - by definition, an empty delta is always commutative under addition with any delta.

 * *Connected values*: For a given set of deltas, *D1*, two values are connected if and only if there is a delta path from one value to the other.
   * Note: According to theorem 
 * *Delta support*: The *delta support* of *V1*, is the set of all deltas _d_ such that _d_ is applicable to at least one value in *V1*. It is equal to the union of all sets of common applicable deltas for all subsets of *V1*.