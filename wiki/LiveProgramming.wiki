#summary Live Programming or Semantic Editing

= Background =

Live programming is proposed as a solution to the [SyntaxProblems Problems of Syntatic Languages]. It is applicable in many semantic models, but has some extra advantages when applied on a [FunctionalProgramming functional programming] semantic model.

= Edit the Semantics, not the Syntax =
In most of today's languages, one edits text characters in a text file, that are later interpreted into semantic models (typically trees with a lot of cross-references).
Instead, a better model is to use a semantic editor that edits the semantic model directly. This has many implications.

= Disadvantages of a semantic editor =
A semantic editor would be specific to one language's semantics, while a normal text editor can edit all text and thus edit programs of all languages.
In practice, though, editors are already semantic-aware in an attempt to help developers, using syntax highlighting and various aids that try to parse the program.  Virtually noone uses generic text-editors to edit programs anymore, and most use language-specific editors (like a language mode in emacs or vi) already.

= A semantic editor is simpler =
Since it does not have to parse and manipulate text in order to aid the programmer, it can actually be much simpler than today's code editors.  The writers of semantic editors can thus focus on adding features that aid the programmer rather than working on parsing and manipulating text.

= The program is runnable at all times = 
By editing the program semantics and not the syntax, the program can have correct semantics at all times. This means it is always runnable, and thus more informative feedback about the program can be given to the programmer. Real-time results of the current code can be shown to the programmer incrementally. This enables [ExampleBasedProgramming Example Based Programming].

= References are real and not by names =
Instead of encoded programs storing cross-references between objects by names, the cross-references will be stored as real references, which are not broken as names are modified.  The programmer can choose an object from the existing objects via the environment's GUI interface (either by drag&drop, or by a semantic-aware name-based query). Due to semantic editing, lexical scopes are unnecessary and the reference to the actual object can be shown graphically and does not need to be resolved.

= Editing vs Running =
Traditionally, editing the program is done by editing its textual representation, while running the program is done by executing a resulting executable.
Via semantic editing, the program is always executable while it is being edited, and does not need to be explicitly "run" as it is always running.  In order to "run" it with different inputs, one just changes the inputs and the outputs are updated accordingly.
This, along with OrthogonalPersistence unifies 3 of the program's different representations ("source code", "executable" and "running form") into one form that is both editable and running. It also allows the developer and user of the program to share one UnifiedInterface to accessing the program. This UnifiedInterface makes every developer of a program a user, and every user of a program a developer of that program.

= Main references =
 # _[http://alarmingdevelopment.org/?p=5 Manifesto of the Programmer Liberation Front]_ Jonathan Edwards (June 16, 2004)

= Additional resources =
 * [http://www.alice.org Alice], for an interesting demo watch the first one on this page: http://www.alice.org/Alice_movies/
 * [http://www.ni.com/labview/ LabView], a tool for "virtual instrumentation", including an graphical interface for "block programming" by connecting outputs to inputs. See the [http://www.ni.com/labview/demos.htm Demos]