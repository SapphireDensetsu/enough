#summary Programming with live code instead of text

_this needs major expansion!_

== Main references ==
 # Ferdinand de Saussure (1916). _The Course of General Linguistics (Cours de linguistique générale)_
 # _[http://en.wikipedia.org/w/index.php?title=Semantics&oldid=107257033 Semantics]_ in Wikipedia
 # _[http://alarmingdevelopment.org/?p=5 Manifesto of the Programmer Liberation Front]_ Jonathan Edwards (June 16, 2004)

=== Additional resources ===
 * [http://www.alice.org Alice], for an interesting demo watch the first one on this page: http://www.alice.org/Alice_movies/
 * [http://www.ni.com/labview/ LabView], a tool for "virtual instrumentation", including an graphical interface for "block programming" by connecting outputs to inputs. See the [http://www.ni.com/labview/demos.htm Demos]

= Background =
Before we start, it is recommended to read about [SyntaxAndSemantics Syntax and Semantics].

== Problems with syntax ==
The external relation between syntax and meaning has a price. There are several limitations and problems.

=== Syntax that is hard to use ===
In some languages (such as written French and Perl) the syntax often causes frustration. In French, the syntactical expression of single words (spelling) is very hard to learn for a newcomer. So is the French syntactical representation of decimal numbers. In Perl, the problem is that the syntax allows to many different ways to specify a single meaning. Of course one can write completely comprehensible programs in perl. But perl allows otherwise, and soon enough this happens, either intentionally (which is ok, because that's what the author wants. See the [http://www.perlmonks.org/index.pl?node_id=45213 Perl Camel] by [http://www.Erudil.com Stephen B. Jenkins]) or because the programmer doesn't value readability (the much more common and very bad case).

Confusing or cumbersome syntax can also lead to errors or just waste time. In C a very common error is caused by confusing = (assignment) with == (equality). The source of this problem is the bad choice of syntax. A time-wasting example in C is forgetting a semicolon after a struct in one header file and receiving many errors in another unrelated file. This problem has its roots in the syntactical rules of source file processing. Our view is that both these example problems actually originate from deeper issues, regarding text.

=== Syntax that doesn't express the semantics naturally ===
Sometimes the syntax imposes restrictions that the semantics don't, causing us to think of things in a more restricted way. _are there any examples? if not, delete this paragraph_

== Textual syntax and its limitations ==
Most programming languages have a textual syntax. The programmer produces a text file containing the source code, and uses a compiler or interpreter to transform this text into code that can run. Any syntactical mistake in the text file may lead to _compilation errors_. Thus, the programmer is forced to waste time on "arguing" with the compiler about what he meant (and unfortunately the compiler is always right).

==== Textual errors that cause semantic errors ====
A worse case is when a syntax error causes a change in the _semantic_ meaning of the program. Here, the program compiles and to the programmer's eye, everything looks fine. Only later (if at all) will the programmer discover that the program is not what he meant it to be, and all because of a typing mistake. The = vs. == example in C is classic - the program compiles and runs but either crashes or acts in an unintended fashion.

=== Text and limitations on programming tools and environment ===
The fact that textual syntax is used also makes it hard to write tools that understand what the code is about. Every new tool must _parse_ the text to reach the meaning of the code. For example, intelligent code completion requires the development environment to parse the source continuously. Although many development environments provide this feature, the mere fact that parsing is required makes it much harder to implement. The same applies for "refactoring" tools that allow you to change the name of a function in every occurance.

=== Modifying textual program structure ===
After a textual source is written, it is very hard to modify the structure of the program. If we want to move a whole set of objects to a different module, we will have to cut and paste the source manually, hopefully not forgetting anything (what if some of the code we move references objects in the old module?). 

If we want to change the name of an object, we will have to search and replace for a textual string, usually through many files, and make sure we only modify those cases where the name actually refers to our object and not to a different one with the same name. As mentioned, there are "refactoring" tools that can ease this task. They can't be perfect - they would need to parse the text in order to know where it is possibly correct to change the name and where it isn't, and even this wouldn't be entirely correct. The tool can not know if the name refers to the same object or to a semantically similar one.

To sum, the limitations of textual syntax go beyond errors. They limit the productivity of programmers by causing them to waste time. The worst result of these limitations is that they cause programmers to give up certain options because of the high cost they incur.

= Live Programming =
== No text editing ==
The real solution to all these problems is to get rid of text-based programming. If the programmer were allowed to edit a higher level representation of code. Instead of editing characters that add up to syntax, which are sub-atomic, we should let the programmer edit at the atomic level. Instead of typing "if (a == b)" the programmer will create an "if" element, and then specify that the objects a and b should be compared (we still need to make sure that the visual representation will prevent confusion with assignment or any other operation). 

== Object references, not names ==
Instead of refering to objects by their names, the programmer will choose an object from a list of existing objects - objects that he has already created. The programmer will see immediately the scope of the refered object, because lexical scope doesn't exist when there is no text. Instead, he will explicitly choose the exact object being refered to. If he wants to create a new object, he will do so explicitly.

_this needs major expansion!_