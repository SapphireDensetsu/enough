#summary Programming with live code instead of text

== Main references ==
 # Ferdinand de Saussure (1916). _The Course of General Linguistics (Cours de linguistique générale)_
 # _[http://en.wikipedia.org/w/index.php?title=Semantics&oldid=107257033 Semantics]_ in Wikipedia
 # _[http://alarmingdevelopment.org/?p=5 Manifesto of the Programmer Liberation Front]_ Jonathan Edwards (June 16, 2004)

=== Additional resources ===
 * [http://www.alice.org Alice], for an interesting demo watch the first one on this page: http://www.alice.org/Alice_movies/
 * [http://www.ni.com/labview/ LabView], a tool for "virtual instrumentation", including an graphical interface for "block programming" by connecting outputs to inputs. See the [http://www.ni.com/labview/demos.htm Demos]

= Introduction =
== Syntax and semantics ==
Every language (not just programming) has several seperate levels or layers, two of which are: syntax and semantics. The syntax layer is the "visible" part of the language: it defines how you write or say what you mean. The semantic layer is the part that determines the underlying structure of the language. 

=== Syntax ===
The syntax has a mission: to convey a meaning. It has no inherent meaning - the meaning of a given syntax is what people agree upon.
In English, the "if...then" construct has a written syntax and a "hidden" semantic meaning. A common syntax is *if* _a_ *then* _b_, where _a_ and _b_ should be syntactically correct English expressions. The _meaning_ of an "if...then" sentence is it's semantics. You may agree to write "If you are stupid, then go away" or "Go away then if your are stupid". A non-standard (and therefore possibly "incorrect" English) syntax can be defined as follows, without using the words "if..then": "you are stupiiid go away". The triple-i spelling mistake in a word signifies "if..then". Or "moo 45!! anti-monsters extereme you are stupid ___KFKSA go away".

*The point* is that syntax is agreed upon to express a certain meaning. Therefore, syntax is arbitrary (besides practical considerations).

In programming languages, a similar principle applies. In C, code with _the same semantics_ for a condition can have a different syntax:
{{{
if (expression)
   statement_for_nonzero
else
   statement_for_zero
}}}
or:
{{{
expression ? statement_for_nonzero : statement_for_zero
}}}
These two syntactical forms have (for our discussion's sake) identical meaning, but not identical syntax.

=== Semantics ===
If syntax is the physical structure of expression, semantics can be loosely defined as the mental structure of the _meaning_. It is not the same to think of a cat as an animal, and to think of a cat as food (yuck!!). Similarly, it is not the same to think of a program in terms of procedures, and to think of the same program in terms of objects.

=== Differing semantics ===
==== Similar but different meanings ====
In natural languages we often have similar but not identical semantics. "If you are stupid, go away" means one things, but "A person who is stupid should go away" means something else. The meaning is similar but not identical. Or we could say "If you _think_ you are stupid, go away". This too has a different meaning (the person could be stupid but not think it). The diversity of semantics allow us to express different meanings.

For computer languages, this is like the difference (in Python) between:
{{{
if stupid in this_person.properties:
   this_person.go_away()
}}}
and:
{{{
for person in people:
   if stupid in person.properties:
      person.should_go_away = True
}}}
and:
{{{
if stupid in this_person.personal_self_opinions:
   this_person.go_away()
}}}
Forgive the silly example. These code pieces differ in their meaning.

==== Different semantics for identical objects of thought ====
The more interesting case is the one mentioned above, regarding procedural vs. object oriented thinking. Notice the word _thinking_. Semantics are more about how we think about something than about its manifestation. In science in general and also very much in software engineering, how you think about something is very important. In many cases, you think about the same problem in several different terms - different semantics.

For a programming example, let's return to the allegedly stupid person:
{{{
if stupid in this_person.properties:
   this_person.go_away()
}}}
This is an object-centered (object oriented if you must) point of view on the person. The same code can be written as:
{{{
if is_stupid(this_person):
   make_go_away(this_person)
}}}
This one is the more procedural point of view. In this simple example it may be less arguable (and not very important) which view is adopted. 

The great question in software design is how to look at a given problem, and _in what context_, or which semantics, to solve it.
