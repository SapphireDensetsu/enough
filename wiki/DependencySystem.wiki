#summary Dependency trees should be automatic!

= Background: Build systems =
Most software projects (except very small ones) require a _build system_ to build correctly. A build system's main feature is the ability to decide what is the correct build order, based on the dependency tree given. For example, if module A requires module B to compile correctly, the programmer will tell the build system about that. When building A, the build system will make sure that B is built (and if not, build it first).

The concept of dependency systems can be generalized beyond software building. A good example is booting Linux. When a Linux system boots, a long list of processes (usually daemons) need to be run. Some of these processes depend on others, and some don't. The usual method for booting Linux is basically a long script that executes the processes sequentially. Some special Linux distributions have come up with a nice way to speed up the boot procedure: they use a build tool (I think _make_) to control the running of processes. If two processes don't depend on each other, the build tool will execute them in parallel. (Although on single-cpu machines this doesn't seem to make any difference, it actually does because of the large amount of I/O performed by these processes.)

This example highlights the fact that a build system is much more than a build system: it is a dependency system.

== Side note: problems with Make ==
Before we go into the various applications of a general dependency systems, let's review the common build systems' faults. We will review _make_, keeping in mind the fact that most build systems have similar limitations:

 * Requires use of special syntax (with its own limitations)
 * Can't detect dependencies automatically
 * Hard to manage (a lot of makefiles)
 * Doesn't identify build changes correctly (e.g., doesn't take into account the switches we passed to the compiler when deciding whether the existing target is new or old)
 * Can't propogate information up or down a tree (e.g., if we want to disable logging in a whole subsystem we need to change the logging variable in all the makefiles of the subsystem)

People who use _make_ usually supplement the build system with scripts that will make it easier to use. This means that the build system fails to supply some very important features. And of course, other build systems exist. Because of these limitations, many people use build systems other than _make_. 

= Dependency Systems =
We haven't survyed the build system market and maybe some of them are quite good. Our point is that dependecies are much more common that just in software building. Some examples follow.

== Engineering ==
A common headache in software (or any other) engineering originates from dependencies. They begin in the _requirements_. The users or customers (a role often played by the designers themselves) define the basic _user requirements_. Sometimes these requirements are quite complex. Often, some requirements were instituted because of other requirements, even at this early stage. The next step is what we call _system requirements_. These are usually defined by the designers of the system when they begin their work. Obviously, many system requirements *depend* on one or more user requirements. Some system requirements depend on other system requirements. Some may depend on implicit requirements (the company's reputation is an implicit requirement!). During the system development process, some new requirements may come up - these too depend on something, usually something that was overlooked previously. Also, some requirements are cancelled later in the project's lifetime.

The eventual outcome of a requirement is some feature of the system being created. Thus, requirements _depend_ on features.

The point is that *requirements are a dependency tree*. If this tree is not documented and managed, mistakes will happen. Someone might cancel a requirement without remembering to cancel all requirements that depend on it, leading to unneccesary work. A much worse scenario is the opposite - cancelling a requirement that is still caused by another existing one. 

In critical systems the managers usually have enough sense to foresee this problem. To solve it, a software "requirements management system" is used. Such a system may supply features that are specific to requirements management. 

For every engineered project, further down the road comes quality assurance, and here too there are dependencies. A test is performed to validate some feature which was developed to fulfill some system requirement that was conceived because of a user requirement (in the average case this example does in fact reflect reality!). This tedious description of engineering dependencies must come to and end and here it is.

The point is that dependencies can pop up everywhere. Sometimes they have a critical significance, and sometimes they can just be used to improve something.

== Dependency System and Live Programming ==