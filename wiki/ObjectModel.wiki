#summary The object model of the entire world.

= Credits =

This is heavily based on the work of Jonathan Edwards (See [www.subtextual.org Subtext]). The majority of the ideas presented here are actually directly taken from Edwards' work in Subtext (with some modifications).

= Introduction =

There is an inherent complexity in the relationship between side-effects and immutable functions. In the following we describe a possible way to reconcile these two conflicting terms and also try to deal with related issues. This document represents the core of our understanding of how the new computing world should function.

= Terminology =

 * *Reference*: A universal link to a value, mutable or function.
 * *Value*: An immutable thing like an integer or a string - these exist "out of" the computer, and will never change.
 * *Mutable*: Typically a container, but can also be "built-in" (i.e implemented via a lower-level mechanism, e.g console). The following mutable objects exist:
  * *Data*: e.g: Arrays, structures (containing fields) and other arbitrary data containers.
  * *Function*: Transform values into new values, in a side-effect free way.
  * *Action*: Modify a Mutable or use other Actions.
  * *Event*: Triggered when a Mutable modification or built-in event occurred, and can be used to invoke Actions.
  * *State*: The entire "world" (all the objects that exist, anywhere) in a certain exact moment.
 * *Now*: The current state (the newest state).
 * *History*: The collection of all *Revisions*.

= State =

The entire "platform state" of *all* the computers in the world (or *State*) at a given moment is composed of all the Objects, Values, Functions, etc. and the inter-relations (i.e references) between them.

*Mutables* only have state due to their part in the entire "world". When a *Mutable* is changed, a new *State* of the entire world is created in which that *Mutable* exists in its new state. This makes it possible to undo back to previous *States* in *History*.

A new state of a Mutable (and therefore the entire world) is created when a the Mutable changes. The only cause for any change in any Mutable can be an Event. When an Event occurs it may trigger one or more Actions which by definition modify the state of Mutables. Furthermore, the mere occurance of an Event means that some Mutable has changed.

Any *State* must be coherent. This means that all Mutables in the State are from "matching versions". If an Event of Mutable "A" has triggered a chain reaction that caused some other Mutable "B" to change, the new State will contain the version of both Mutables, *after* the change.

== Implementation ==

There is no actual data structure that stores the entirety of the *State*. It is more of a logical construct to facilitate understanding of object versions.

Every *Mutable* has an associated version number, that refers to the *State* it belongs to. A *State* is actually the collection of all *Mutables* of a certain version number or the latest one older than it.

Modifications of remote *Mutables* (that live on other computers) are associated with a local version number so that a remote object version can be associated with a local *State*. The implementation of this TBD.

= Values =

Immutable values exist in thin air, and are referred to by other objects via 


= 